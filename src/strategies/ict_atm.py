"""ICT ATM (Accumulation-To-Manipulation) method implementation for XAUUSD.

The logic below follows the original ICT mentorship transcript describing the ATM
pattern on the 60-minute chart:

1. Identify a key high (bearish setup) or key low (bullish setup) created by a
   stop run / liquidity raid ? typically the second push in a two-stage move.
2. Confirm a break in market structure (BMS) by trading through the opposing
   swing (sell-side liquidity for bearish, buy-side for bullish).
3. Wait for price to retrace back to the dealing range low/high that formed
   prior to the key high/low ? effectively retesting the old support/resistance
   level that was violated during the stop run.
4. Trade in the direction of the structure break, framing risk above/below the
   key high/low and targeting the liquidity resting beyond the structure break.

The implementation monitors 1-hour data, requiring the break to occur before any
entry is considered. Entries are only produced once price revisits the
retest-zone after the break, matching the transcript guidance of ?waiting for
price to retrace back to the swing low/high that formed prior to the key
high/low.?
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import pandas as pd
import pytz


@dataclass
class ICTATMSignal:
    """Structured signal generated by the ICT ATM method."""

    timestamp: datetime
    symbol: str
    direction: int  # 1 = buy, -1 = sell
    entry_price: float
    stop_loss: float
    take_profit_primary: float
    take_profit_secondary: Optional[float] = None
    take_profit_tertiary: Optional[float] = None
    confidence: float = 0.0
    risk_reward: float = 0.0
    notes: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_payload(self) -> Dict[str, Any]:
        return {
            "timestamp": self.timestamp.isoformat(),
            "symbol": self.symbol,
            "direction": self.direction,
            "entry_price": float(self.entry_price),
            "stop_loss": float(self.stop_loss),
            "take_profit_primary": float(self.take_profit_primary),
            "take_profit_secondary": float(self.take_profit_secondary)
            if self.take_profit_secondary is not None
            else None,
            "take_profit_tertiary": float(self.take_profit_tertiary)
            if self.take_profit_tertiary is not None
            else None,
            "confidence": float(self.confidence),
            "risk_reward": float(self.risk_reward),
            "notes": self.notes,
            "metadata": dict(self.metadata),
        }


class ICTATMStrategy:
    """Implements the ICT ATM methodology on 60-minute data."""

    def __init__(
        self,
        symbol: str = "XAUUSD",
        timezone: str = "UTC",
        max_pattern_age_hours: int = 48,
    ) -> None:
        self.symbol = symbol.upper()
        self.timezone = pytz.timezone(timezone)
        self.max_pattern_age = timedelta(hours=max_pattern_age_hours)
        self._last_diagnostics: Dict[str, Any] = {
            "status": "init",
            "reason": None,
            "summary": {},
            "signals": [],
        }

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------
    def evaluate(
        self,
        historical_data: pd.DataFrame,
        current_quote: Dict[str, Any],
    ) -> Tuple[List[ICTATMSignal], Dict[str, Any]]:
        diagnostics: Dict[str, Any] = {
            "status": "init",
            "reason": None,
            "summary": {},
            "signals": [],
        }

        signals: List[ICTATMSignal] = []

        # Support any gold symbol (XAUUSD, XAUUSDm, GOLD, etc.)
        symbol_upper = (self.symbol or "").upper()
        is_gold = ("XAU" in symbol_upper) or ("GOLD" in symbol_upper)
        if not is_gold:
            diagnostics.update({"status": "skipped", "reason": "unsupported_symbol"})
            self._last_diagnostics = diagnostics
            return signals, diagnostics

        if historical_data is None or historical_data.empty:
            diagnostics.update({"status": "skipped", "reason": "missing_history"})
            self._last_diagnostics = diagnostics
            return signals, diagnostics

        base_cols = [c for c in ["Open", "High", "Low", "Close", "Volume"] if c in historical_data.columns]
        if len(base_cols) < 4:
            diagnostics.update({"status": "skipped", "reason": "missing_columns"})
            self._last_diagnostics = diagnostics
            return signals, diagnostics

        h1 = self._prepare_h1_bars(historical_data[base_cols])
        if h1.empty or len(h1) < 60:
            diagnostics.update({"status": "skipped", "reason": "insufficient_h1_bars"})
            self._last_diagnostics = diagnostics
            return signals, diagnostics

        atr_series = self._compute_atr(h1, period=14)
        atr_current = float(atr_series.iloc[-1]) if not atr_series.empty else np.nan
        if np.isnan(atr_current) or atr_current <= 0:
            atr_current = max(float((h1["High"] - h1["Low"]).tail(14).mean()), 3.0)

        current_ts = pd.Timestamp(current_quote.get("timestamp", datetime.utcnow()))
        if current_ts.tzinfo is None:
            current_ts = current_ts.tz_localize("UTC")
        current_local = current_ts.tz_convert(self.timezone)
        current_price = float(current_quote.get("price") or h1.iloc[-1]["Close"])

        tolerance = max(atr_current * 0.25, current_price * 0.0005)

        diagnostics["summary"] = {
            "timestamp": current_local.isoformat(),
            "current_price": current_price,
            "atr_current": round(float(atr_current), 3),
            "tolerance": round(float(tolerance), 3),
            "h1_bars": int(len(h1)),
        }

        bearish_setup = self._find_bearish_setup(h1, atr_current, tolerance, current_price, current_ts)
        bullish_setup = self._find_bullish_setup(h1, atr_current, tolerance, current_price, current_ts)

        if bearish_setup:
            signal = self._build_signal(
                direction=-1,
                current_price=current_price,
                atr_current=atr_current,
                tolerance=tolerance,
                current_local=current_local,
                notes="ATM bearish: stop run above prior high, structure break, retest of old support",
                **bearish_setup,
            )
            signals.append(signal)
            diagnostics.setdefault("summary", {})["bearish_pattern"] = {
                "key_high": round(float(bearish_setup["key_level"]), 3),
                "structure_low": round(float(bearish_setup["structure_level"]), 3),
                "target_liquidity": round(float(bearish_setup["target_level"]), 3),
                "pattern_age_hours": round(bearish_setup["pattern_age"].total_seconds() / 3600, 2),
            }
        else:
            diagnostics.setdefault("summary", {})["bearish_pattern"] = "none"

        if bullish_setup:
            signal = self._build_signal(
                direction=1,
                current_price=current_price,
                atr_current=atr_current,
                tolerance=tolerance,
                current_local=current_local,
                notes="ATM bullish: stop run below prior low, structure break, retest of old resistance",
                **bullish_setup,
            )
            signals.append(signal)
            diagnostics.setdefault("summary", {})["bullish_pattern"] = {
                "key_low": round(float(bullish_setup["key_level"]), 3),
                "structure_high": round(float(bullish_setup["structure_level"]), 3),
                "target_liquidity": round(float(bullish_setup["target_level"]), 3),
                "pattern_age_hours": round(bullish_setup["pattern_age"].total_seconds() / 3600, 2),
            }
        else:
            diagnostics.setdefault("summary", {})["bullish_pattern"] = "none"

        if signals:
            diagnostics.update({
                "status": "signal",
                "reason": "atm_pattern_ready",
                "signals": [sig.to_payload() for sig in signals],
            })
        else:
            diagnostics.update({"status": "hold", "reason": "no_atm_pattern"})

        self._last_diagnostics = diagnostics
        return signals, diagnostics

    def get_last_diagnostics(self) -> Dict[str, Any]:
        return dict(self._last_diagnostics)

    # ------------------------------------------------------------------
    # Data preparation helpers
    # ------------------------------------------------------------------
    def _prepare_h1_bars(self, data: pd.DataFrame) -> pd.DataFrame:
        df = data.copy().dropna()
        df.index = pd.to_datetime(df.index)
        try:
            df.index = df.index.tz_localize("UTC")
        except TypeError:
            if df.index.tz is None:
                df.index = df.index.tz_localize("UTC")
        h1 = df.resample("1h", label="right", closed="right").agg(
            {"Open": "first", "High": "max", "Low": "min", "Close": "last", "Volume": "sum"}
        )
        h1 = h1.dropna(how="any")
        if len(h1) > 240:
            h1 = h1.tail(240)
        return h1

    def _compute_atr(self, data: pd.DataFrame, period: int = 14) -> pd.Series:
        high_low = data["High"] - data["Low"]
        high_close = (data["High"] - data["Close"].shift()).abs()
        low_close = (data["Low"] - data["Close"].shift()).abs()
        true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
        atr = true_range.rolling(window=period).mean()
        return atr

    # ------------------------------------------------------------------
    # Pattern detection
    # ------------------------------------------------------------------
    def _find_bearish_setup(
        self,
        h1: pd.DataFrame,
        atr_current: float,
        tolerance: float,
        current_price: float,
        current_ts: pd.Timestamp,
    ) -> Optional[Dict[str, Any]]:
        pivot_indices = self._fractal_indices(h1["High"], kind="high")
        if len(pivot_indices) < 2:
            return None

        for idx2 in reversed(pivot_indices[-10:]):  # check most recent pivots
            time2 = h1.index[idx2]
            if current_ts - time2 > self.max_pattern_age:
                continue
            if idx2 < 3:
                continue
            prev_pivots = [i for i in pivot_indices if i < idx2]
            if not prev_pivots:
                continue
            idx1 = prev_pivots[-1]
            high2 = float(h1["High"].iloc[idx2])
            high1 = float(h1["High"].iloc[idx1])
            if high2 <= high1:
                continue

            swing_slice = h1.iloc[idx1: idx2 + 1]
            structure_low = float(swing_slice["Low"].min())
            structure_low_time = swing_slice["Low"].idxmin()

            post = h1.iloc[idx2 + 1 :]
            if post.empty:
                continue
            breaks = post[post["Low"] < structure_low]
            if breaks.empty:
                continue  # structure has not broken yet
            break_time = breaks.index[0]
            if current_ts <= break_time:
                continue  # waiting for a completed break bar
            if current_ts - break_time > self.max_pattern_age:
                continue

            target_low = float(h1.loc[break_time:]["Low"].min())

            # Retest condition ? current price must revisit the violated structure level
            if abs(current_price - structure_low) > tolerance:
                continue

            displacement = high2 - high1
            structure_break = structure_low - float(post.loc[break_time]["Close"])

            return {
                "key_level": high2,
                "key_time": time2,
                "structure_level": structure_low,
                "structure_time": structure_low_time,
                "break_time": break_time,
                "target_level": target_low,
                "pattern_age": current_ts - break_time,
                "impulse_displacement": displacement,
                "structure_break": structure_break,
            }
        return None

    def _find_bullish_setup(
        self,
        h1: pd.DataFrame,
        atr_current: float,
        tolerance: float,
        current_price: float,
        current_ts: pd.Timestamp,
    ) -> Optional[Dict[str, Any]]:
        pivot_indices = self._fractal_indices(h1["Low"], kind="low")
        if len(pivot_indices) < 2:
            return None

        for idx2 in reversed(pivot_indices[-10:]):
            time2 = h1.index[idx2]
            if current_ts - time2 > self.max_pattern_age:
                continue
            if idx2 < 3:
                continue
            prev_pivots = [i for i in pivot_indices if i < idx2]
            if not prev_pivots:
                continue
            idx1 = prev_pivots[-1]
            low2 = float(h1["Low"].iloc[idx2])
            low1 = float(h1["Low"].iloc[idx1])
            if low2 >= low1:
                continue

            swing_slice = h1.iloc[idx1: idx2 + 1]
            structure_high = float(swing_slice["High"].max())
            structure_high_time = swing_slice["High"].idxmax()

            post = h1.iloc[idx2 + 1 :]
            if post.empty:
                continue
            breaks = post[post["High"] > structure_high]
            if breaks.empty:
                continue
            break_time = breaks.index[0]
            if current_ts <= break_time:
                continue
            if current_ts - break_time > self.max_pattern_age:
                continue

            target_high = float(h1.loc[break_time:]["High"].max())

            if abs(current_price - structure_high) > tolerance:
                continue

            displacement = low1 - low2
            structure_break = float(post.loc[break_time]["Close"]) - structure_high

            return {
                "key_level": low2,
                "key_time": time2,
                "structure_level": structure_high,
                "structure_time": structure_high_time,
                "break_time": break_time,
                "target_level": target_high,
                "pattern_age": current_ts - break_time,
                "impulse_displacement": displacement,
                "structure_break": structure_break,
            }
        return None

    def _fractal_indices(self, series: pd.Series, kind: str = "high", lookback: int = 2) -> List[int]:
        values = series.values
        indices: List[int] = []
        for i in range(lookback, len(values) - lookback):
            window = values[i - lookback : i + lookback + 1]
            center = values[i]
            if kind == "high" and center == window.max() and (window > center).sum() == 0:
                indices.append(i)
            if kind == "low" and center == window.min() and (window < center).sum() == 0:
                indices.append(i)
        return indices

    # ------------------------------------------------------------------
    # Signal construction
    # ------------------------------------------------------------------
    def _build_signal(
        self,
        direction: int,
        current_price: float,
        atr_current: float,
        tolerance: float,
        current_local: pd.Timestamp,
        notes: str,
        key_level: float,
        structure_level: float,
        target_level: float,
        impulse_displacement: float,
        structure_break: float,
        pattern_age: timedelta,
        **_: Any,
    ) -> ICTATMSignal:
        buffer = max(atr_current * 0.35, tolerance)

        if direction == -1:
            stop_loss = key_level + buffer
            risk = max(stop_loss - current_price, 0.1)
            primary_target = min(target_level, current_price - risk * 2.0)
            secondary_target = current_price - risk * 3.0
            tertiary_target = current_price - risk * 4.0
        else:
            stop_loss = key_level - buffer
            risk = max(current_price - stop_loss, 0.1)
            primary_target = max(target_level, current_price + risk * 2.0)
            secondary_target = current_price + risk * 3.0
            tertiary_target = current_price + risk * 4.0

        risk_reward = abs((primary_target - current_price) / risk) if risk else 0.0

        # Confidence blends proximity to retest zone and quality of structure break
        retrace_alignment = max(0.0, 1.0 - abs(current_price - structure_level) / max(tolerance, 1e-6))
        displacement_quality = min(abs(impulse_displacement) / max(atr_current, 1e-6), 3.0)
        break_quality = min(abs(structure_break) / max(atr_current * 0.5, 1e-6), 3.0)
        age_penalty = max(0.0, 1.0 - pattern_age.total_seconds() / self.max_pattern_age.total_seconds())

        confidence_from_retrace = retrace_alignment * 40.0
        confidence = confidence_from_retrace + displacement_quality * 20.0 + break_quality * 20.0 + age_penalty * 20.0
        confidence = max(0.0, min(100.0, confidence))

        metadata = {
            "structure_level": round(float(structure_level), 3),
            "key_level": round(float(key_level), 3),
            "target_level": round(float(primary_target), 3),
            "atr_current": round(float(atr_current), 3),
            "tolerance": round(float(tolerance), 3),
            "impulse_displacement": round(float(impulse_displacement), 3),
            "structure_break": round(float(structure_break), 3),
            "pattern_age_minutes": int(pattern_age.total_seconds() / 60),
        }

        return ICTATMSignal(
            timestamp=current_local.to_pydatetime(),
            symbol=self.symbol,
            direction=direction,
            entry_price=current_price,
            stop_loss=stop_loss,
            take_profit_primary=primary_target,
            take_profit_secondary=secondary_target,
            take_profit_tertiary=tertiary_target,
            confidence=confidence,
            risk_reward=risk_reward,
            notes=notes,
            metadata=metadata,
        )

